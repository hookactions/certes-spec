# Event Consumer

[summary](_media/event-consumer-summary.md ':include')

## New events

I'm still undecided about the best way to handle this, but ideally this component would declare the following GRPC service:

```protobuf
service EventConsumer {
  rpc ProcessEventfromQueue(...) return (...) {}
}
```

`ProcessEventfromQueue` would be invoked when there are new messages in the Message Queue. However, this may just be an internal interface because of the different queues to be supported.

```go
type EventConsumer interface {
  ProcessEventfromQueue(...)
}

type EventQueue interface {
  Subscribe() chan *Event
}

type EventConsumerDelegator struct {
  consumer EventConsumer
  source   EventQueue
}

func (d EventConsumerDelegator) Run() {
  ch := d.source.Subscribe()

  for event := range ch {
    d.consumer.ProcessEventfromQueue(event)
  }
}
```

## HMAC signing

The Event Broker ensures that the event received from a Publisher is actually sent from the expected Publisher by means of [Authentication](/event-broker#authentication). The downstream consumer of this event is expecting an HMAC signature to verify that the event was actually sent by the expected Certes application.

The verification of the HMAC signature is handled automatically by the `certes` client SDKs. The secret is stored in the Master API, which is retrieved by the Event Consumer to generate the correct signature. The downstream consumer also retrieves this from the same Master API through the public Event Gateway and is authenticated to ensure proper access.

At the time of writing the most secure implementation is an HMAC using SHA256. When a more secure and equally performant cryptographic method is created we will consider using it. To support this future use case, we should define the HMAC header using the specific version of the signature:

```
HMAC-SIG: SHA1 de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
HMAC-SIG: SHA256 f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8
```

_`SHA1` is just an example and is NOT supported by Certes._

## Downstream consumer

The downstream consumer is the consumer of the event generated by the Event Consumer. This is an HTTP API or application that lives outside the context of Certes but uses the Certes SDK. This would be a program like so:

```go
package main

import (
  "fmt"
  "net/http"

  certes "github.com/hookactions/certes-sdk/go"
  gh "github.com/hookactions/certes-contrib/github"
)

func init() {
  certes.Init("events://events.meetly.com")  // Meetly's event gateway, local or hosted by 3rd party
  
  certes.EnsureSubscriptions(
    certes.Event("community.certes.dev/github/1/push", nil),
    certes.Event("community.certes.dev/github/1/issues", &gh.Opts{
      Repo: "meetly/app",
    }),
    certes.Event("community.certes.dev/github/1/membership", &gh.Opts{
      Org: "meetly",
    }),
    certes.Event("community.certes.dev/github/1/*", &gh.Opts{
      Repo: "meetly/meetly",
    }),
  )
}

func main() {
  certes.On("community.certes.dev/github/1/push", func(raw *certes.RawEvent) error {
    var event gh.PushEvent
    if err := raw.To(&event); err != nil {
      return err
    }

    fmt.Printf("Got Github push event: %#v\n", event)
    return nil
  })

  http.HandleFunc("/", certes.HttpHandler())
  log.Fatal(http.ListenAndServe(":8080", nil))
}
```

## Failure and back-off

Downstream consumers may fail to process the event or may just be down for maintenance or high load. Failures are inevitable and to handle these cases, the Event Consumer will catch any error and requeue the Event (by means of the Event Broker) and specify a back-off of when to try to handle the Event again.

[summary](_media/backoffs-summary.md ':include')
